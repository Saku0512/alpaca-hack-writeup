# Safe Prime

> Using a [safe prime](https://en.wikipedia.org/wiki/Safe_prime) makes RSA secure, doesn't it?

`output.txt`と`chall.py`が提供される。

output.txt
```txt
n = 292927367433510948901751902057717800692038691293351366163009654796102787183601223853665784238601655926920628800436003079044921928983307813012149143680956641439800408783429996002829316421340550469318295239640149707659994033143360850517185860496309968947622345912323183329662031340775767654881876683235701491291
c = 40791470236110804733312817275921324892019927976655404478966109115157033048751614414177683787333122984170869148886461684367352872341935843163852393126653174874958667177632653833127408726094823976937236033974500273341920433616691535827765625224845089258529412235827313525710616060854484132337663369013424587861
```

chall.py
```py
import os
from Crypto.Util.number import getPrime, isPrime

FLAG = os.getenv("FLAG", "ctf4b{*** REDACTED ***}").encode()
m = int.from_bytes(FLAG, 'big')

while True:
    p = getPrime(512)
    q = 2 * p + 1
    if isPrime(q):
        break

n = p * q
e = 65537
c = pow(m, e, n)

print(f"{n = }")
print(f"{c = }")
```

```py
q = 2 * p + 1
```
ここが脆弱

$$
n = p(2p + 1)
$$


$$
n = 2p^2 + p
$$


これを整形する

$$
2p^2 + p - n = 0
$$


この二次方程式を解の公式 $p = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a}$ を使って解くと、 $p$  を直接求めることができます。
ここで $a=2, b=1, c=-n$ なので、

$$
p = \frac{-1 + \sqrt{1 - 4 \cdot 2 \cdot (-n)}}{4} = \frac{-1 + \sqrt{1 + 8n}}{4}
$$

$n$ が分かれば $p$ が求まり、$p$ が分かれば $q$ も求まるので、秘密鍵 $d$ を復元して復号できます。

`output.txt`で`n`が提供されているので解く。

```py
from Crypto.Util.number import long_to_bytes
import math

# 与えられたパラメータ
n = 292927367433510948901751902057717800692038691293351366163009654796102787183601223853665784238601655926920628800436003079044921928983307813012149143680956641439800408783429996002829316421340550469318295239640149707659994033143360850517185860496309968947622345912323183329662031340775767654881876683235701491291
c = 40791470236110804733312817275921324892019927976655404478966109115157033048751614414177683787333122984170869148886461684367352872341935843163852393126653174874958667177632653833127408726094823976937236033974500273341920433616691535827765625224845089258529412235827313525710616060854484132337663369013424587861
e = 65537

# 1. p を求める
# 判別式 D = 1 + 8n
discriminant = 1 + 8 * n

# Dの平方根 (整数)
sqrt_val = math.isqrt(discriminant)

# p = (-1 + sqrt(1 + 8n)) / 4
p = (sqrt_val - 1) // 4

# 2. q を求める
q = 2 * p + 1

# 検算 (正しく因数分解できたか確認)
assert p * q == n, "因数分解に失敗しました"

# 3. 秘密鍵 d を求めて復号する
phi = (p - 1) * (q - 1)
d = pow(e, -1, phi)
m = pow(c, d, n)

# 4. フラグを表示
print(long_to_bytes(m).decode())
```

```
> python solve.py
ctf4b{R3l4ted_pr1m3s_4re_vuLner4ble_n0_maTt3r_h0W_l4rGe_p_1s}
```

flag: `ctf4b{R3l4ted_pr1m3s_4re_vuLner4ble_n0_maTt3r_h0W_l4rGe_p_1s}`
